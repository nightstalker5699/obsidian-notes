# Summary of SQL Window Functions

These transcripts cover several key SQL window functions, demonstrating their usage and nuances.

## Key Window Functions Explained:

### 1. Cumulative Sum (SUM with PARTITION BY and ORDER BY)
- Creates running totals within partitions
- Example: Tracking cumulative customer spending over time
- Requires both PARTITION BY (customer_id) and ORDER BY (order_id)
- Without ORDER BY, you just get the total sum per partition
**Use Case**: Track a customer's cumulative spending over time

```sql
SELECT 
    order_id,
    customer_id,
    net_amount,
    SUM(net_amount) OVER(
        PARTITION BY customer_id 
        ORDER BY order_id
    ) AS cumulative_spending
FROM orders;
```

**Sample Output**:
```
order_id | customer_id | net_amount | cumulative_spending
---------+-------------+------------+--------------------
1        | 13          | 227.00     | 227.00
2        | 13          | 83.76      | 310.76
3        | 13          | 150.50     | 461.26
1        | 27          | 95.99      | 95.99
```

### 2. ROW_NUMBER()
- Assigns sequential numbers to rows within a partition
- Ignores framing - always numbers all rows in partition
- Useful for ranking items (e.g., products by price within categories)
- Syntax: `ROW_NUMBER() OVER(PARTITION BY category ORDER BY price)`
**Use Case**: Rank products by price within each category

```sql
SELECT 
    product_id,
    product_name,
    category,
    price,
    ROW_NUMBER() OVER(
        PARTITION BY category 
        ORDER BY price DESC
    ) AS price_rank
FROM products;
```

**Sample Output**:
```
product_id | product_name   | category  | price | price_rank
-----------+----------------+-----------+-------+-----------
101        | Premium Widget | Electronics | 299.99 | 1
102        | Basic Widget   | Electronics | 199.99 | 2
203        | Deluxe Gadget  | Home       | 149.99 | 1
204        | Standard Gadget| Home       | 99.99  | 2
```

### 3. FIRST_VALUE()
- Returns value from first row in window frame
- Typically used with ORDER BY to get extreme values
- Example: Finding lowest price in each category
- Can often be replaced with MIN() for simpler syntax
**Use Case**: Compare each product's price to the lowest price in its category

```sql
SELECT 
    product_id,
    product_name,
    category,
    price,
    FIRST_VALUE(price) OVER(
        PARTITION BY category 
        ORDER BY price
        RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS lowest_price_in_category
FROM products;
```

**Alternative with MIN()**:
```sql
SELECT 
    product_id,
    product_name,
    category,
    price,
    MIN(price) OVER(PARTITION BY category) AS lowest_price_in_category
FROM products;
```

**Sample Output**:
```
product_id | product_name   | category  | price | lowest_price_in_category
-----------+----------------+-----------+-------+-------------------------
102        | Basic Widget   | Electronics | 199.99 | 199.99
101        | Premium Widget | Electronics | 299.99 | 199.99
204        | Standard Gadget| Home       | 99.99  | 99.99
203        | Deluxe Gadget  | Home       | 149.99 | 99.99
```

### 4. LAST_VALUE()
- Returns value from last row in window frame
- Requires careful framing to work as expected
- Default frame may not include entire partition
- Solution: `RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`
- Often better replaced with MAX() for simplicity
**Use Case**: Compare each product's price to the highest price in its category

```sql
SELECT 
    product_id,
    product_name,
    category,
    price,
    LAST_VALUE(price) OVER(
        PARTITION BY category 
        ORDER BY price
        RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS highest_price_in_category
FROM products;
```

**Alternative with MAX()**:
```sql
SELECT 
    product_id,
    product_name,
    category,
    price,
    MAX(price) OVER(PARTITION BY category) AS highest_price_in_category
FROM products;
```

**Sample Output**:
```
product_id | product_name   | category  | price | highest_price_in_category
-----------+----------------+-----------+-------+--------------------------
101        | Premium Widget | Electronics | 299.99 | 299.99
102        | Basic Widget   | Electronics | 199.99 | 299.99
203        | Deluxe Gadget  | Home       | 149.99 | 149.99
204        | Standard Gadget| Home       | 99.99  | 149.99
```

```sql
-- Without proper framing (incorrect - only compares to current row):
SELECT 
    product_id,
    LAST_VALUE(price) OVER(
        PARTITION BY category 
        ORDER BY price
        -- Default frame: RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS incorrect_highest_price
FROM products;

-- With proper framing (correct - compares to entire partition):
SELECT 
    product_id,
    LAST_VALUE(price) OVER(
        PARTITION BY category 
        ORDER BY price
        RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS correct_highest_price
FROM products;
```

## Key Insights:

1. **Framing Matters**: Window functions behave differently based on frame clauses
   - Default frame: `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`
   - For LAST_VALUE(), often need unbounded following

2. **ORDER BY Changes Behavior**:
   - Without ORDER BY: operates on entire partition
   - With ORDER BY: creates running calculations

3. **Simpler Alternatives Exist**:
   - FIRST_VALUE/LAST_VALUE often replaceable with MIN/MAX
   - Choose based on readability and performance

4. **Mental Models Help**:
   - Visualize partitions and frames to understand function behavior
   - Experiment with different approaches to find optimal solutions

These window functions provide powerful analytical capabilities for comparing values within data partitions and tracking changes over sequences of rows.
