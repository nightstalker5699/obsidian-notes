### Summary of "Solving For Current Salary English.txt"

The text demonstrates how to use **window functions** to accurately retrieve an employee's **current salary**, addressing limitations of traditional `GROUP BY` approaches. Here are the key insights:

---

#### **1. Problem with `GROUP BY`**  
- **Max Salary â‰  Current Salary**:  
  - `GROUP BY` with `MAX(salary)` fails if salaries decrease (e.g., due to demotions or recessions).  
  - Example: An employeeâ€™s highest salary ($100K in 2020) might not reflect their current salary ($80K in 2023).  

#### **2. Window Function Solution**  
- **Approach**: Use `LAST_VALUE()` with precise framing to fetch the most recent salary based on the `from_date`.  
- **Query**:  
  ```sql
  SELECT DISTINCT 
    e.employee_id,
    e.first_name,
    d.department_name,
    LAST_VALUE(s.salary) OVER (
      PARTITION BY s.employee_id 
      ORDER BY s.from_date
      RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS current_salary,
    LAST_VALUE(s.from_date) OVER (
      PARTITION BY s.employee_id 
      ORDER BY s.from_date
      RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS salary_date
  FROM employees e
  JOIN salaries s ON e.employee_id = s.employee_id
  JOIN departments d ON e.department_id = d.department_id;
  ```
  - **Key Components**:  
    - `PARTITION BY employee_id`: Groups data by employee.  
    - `ORDER BY from_date`: Sorts salaries chronologically.  
    - `RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`: Ensures `LAST_VALUE()` scans the entire partition (not just rows up to the current date).  

#### **3. Why Framing Matters**  
- **Default Behavior**: Without explicit framing, `ORDER BY` limits the window to rows **up to the current row**, making `LAST_VALUE()` return the current rowâ€™s value (not the partitionâ€™s true last value).  
- **Fix**: The `RANGE` clause expands the window to the entire partition.  

#### **4. Verification**  
- **Cross-Check**: The query also retrieves the `from_date` of the last salary to validate correctness (e.g., confirming `salary=80K` aligns with `from_date=2023-01-01`).  

#### **5. Alternatives & Trade-offs**  
- **Subqueries**: Could use `WHERE from_date = (SELECT MAX(from_date) FROM salaries WHERE employee_id = e.employee_id)`.  
- **Performance**: Window functions may be slower than subqueries for large datasets due to row-by-row processing.  
- **Readability**: Window functions are powerful but complex; simpler methods might be preferable for maintenance.  

#### **6. Additional Window Functions**  
- **`FIRST_VALUE()`**: Retrieves the earliest salary in the partition.  
- **`NTH_VALUE()`**: Fetches the salary at a specific position (e.g., second raise).  
- **Ranking Functions**: `RANK()`, `DENSE_RANK()`, `ROW_NUMBER()` for comparative analysis.  

#### **7. Key Takeaways**  
- **Precision**: Window functions with framing provide accurate results for time-sensitive queries.  
- **Flexibility**: Suitable for scenarios where `GROUP BY` falls short (e.g., non-monotonic data).  
- **Use Cases**: Employee history analysis, financial tracking, and other temporal data challenges.  

---

### **Next Steps**:  
Explore other window functions like `LAG()`/`LEAD()` to compare current salaries with previous/future values, or use `ROW_NUMBER()` to identify salary trends per employee.  

**Window functions + framing = Robust temporal data analysis.** ðŸš€