# Understanding Framing in PostgreSQL Window Functions

Framing is a crucial concept in window functions that determines exactly which rows within a partition are included in the calculation for each row. When you use the `OVER()` clause with `ORDER BY`, PostgreSQL automatically applies a default frame, but you can customize this behavior.

## What is a Frame?

A frame is a subset of rows within a window partition that the window function considers when performing its calculation for the current row. The frame moves with the current row being processed.

## Frame Syntax

The complete frame specification looks like:
```sql
ROWS|RANGE|GROUPS BETWEEN frame_start AND frame_end
```

Where:
- `ROWS`/`RANGE`/`GROUPS` determines how to measure the frame
- `frame_start` and `frame_end` can be:
  - `UNBOUNDED PRECEDING` (start of partition)
  - `CURRENT ROW`
  - `value PRECEDING` (for ROWS/RANGE/GROUPS)
  - `value FOLLOWING` (for ROWS/RANGE/GROUPS)
  - `UNBOUNDED FOLLOWING` (end of partition)

## Default Framing Behavior

1. **With ORDER BY**:
   ```sql
   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
   ```
   This creates a running frame that includes all rows from the partition start up to the current row.

2. **Without ORDER BY**:
   ```sql
   RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
   ```
   This includes all rows in the partition.

## Frame Types

### 1. ROWS - Physical Rows
Counts exact row positions relative to current row.

**Example: 3-row trailing average**
```sql
SELECT 
    date,
    sales,
    AVG(sales) OVER(ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg
FROM daily_sales;
```

### 2. RANGE - Logical Value Range
Groups rows based on their ordered values.

**Example: Include all rows with same date value**
```sql
SELECT 
    date,
    sales,
    SUM(sales) OVER(ORDER BY date RANGE CURRENT ROW) AS daily_total
FROM sales_with_duplicates;
```

### 3. GROUPS - Peer Groups
Counts groups of rows with the same ORDER BY values (PostgreSQL 11+).

**Example: Include current and previous group**
```sql
SELECT 
    date,
    sales,
    SUM(sales) OVER(ORDER BY date GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW)
FROM sales_data;
```

## Practical Examples

### Running Total vs. Windowed Sum

**Running total (default frame):**
```sql
SELECT 
    date,
    sales,
    SUM(sales) OVER(ORDER BY date) AS running_total
FROM daily_sales;
```

**3-day moving sum (custom frame):**
```sql
SELECT 
    date,
    sales,
    SUM(sales) OVER(ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_sum
FROM daily_sales;
```

### Comparing ROWS vs RANGE

**ROWS (exact 2 rows before):**
```sql
SELECT 
    value,
    AVG(value) OVER(ORDER BY value ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
FROM measurements;
```

**RANGE (values within 10 units):**
```sql
SELECT 
    value,
    AVG(value) OVER(ORDER BY value RANGE BETWEEN 10 PRECEDING AND CURRENT ROW)
FROM measurements;
```

## When to Use Framing

1. Moving averages/sums
2. Calculating running totals
3. Comparing current row with nearby rows
4. Creating sliding window calculations
5. Handling tied values differently

Understanding framing gives you precise control over how your window functions accumulate values and is essential for advanced time series and analytical queries.****