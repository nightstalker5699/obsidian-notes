# Comprehensive Guide to Inserting Data and Managing Constraints in PostgreSQL

## Inserting Data into Tables

### Basic INSERT Syntax
```sql
INSERT INTO table_name (column1, column2, ...)
VALUES (value1, value2, ...);
```

### Inserting a Student
```sql
INSERT INTO student (first_name, last_name, email, date_of_birth)
VALUES (
  'Mo', 
  'Beenie', 
  'mo@beenie.com', 
  '1990-01-01'::DATE
);
```

### Inserting a Teacher
```sql
INSERT INTO teacher (first_name, last_name, email, date_of_birth)
VALUES (
  'Mo', 
  'Beenie', 
  'mo@beenie.com', 
  '1990-01-01'::DATE
);
```

## Creating Courses with Proper Constraints

### 1. First Insert a Subject
```sql
INSERT INTO subject (subject_name, description)
VALUES (
  'SQL', 
  'Database management language'
);
```

### 2. Then Create a Course
```sql
INSERT INTO course (
  course_name, 
  description, 
  subject_id, 
  teacher_id
)
VALUES (
  'Zero to Mastery SQL', 
  'The #1 resource for SQL mastery', 
  (SELECT subject_id FROM subject WHERE subject_name = 'SQL'),
  (SELECT teacher_id FROM teacher WHERE email = 'mo@beenie.com')
);
```

## Fixing Missing Constraints

### Identifying the Problem
The course table was created without NOT NULL constraints on foreign keys:
```sql
CREATE TABLE course (
  course_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  course_name TEXT NOT NULL,
  description TEXT,
  subject_id UUID REFERENCES subject(subject_id),  -- Missing NOT NULL
  teacher_id UUID REFERENCES teacher(teacher_id), -- Missing NOT NULL
  feedback feedback_type[]
);
```

### Solution: Adding Constraints After Data Migration

1. First update existing null values:
```sql
-- Update subject_id for existing courses
UPDATE course 
SET subject_id = (SELECT subject_id FROM subject WHERE subject_name = 'SQL')
WHERE subject_id IS NULL;

-- Update teacher_id for existing courses
UPDATE course 
SET teacher_id = (SELECT teacher_id FROM teacher WHERE email = 'mo@beenie.com')
WHERE teacher_id IS NULL;
```

2. Then add NOT NULL constraints:
```sql
-- Add NOT NULL to subject_id
ALTER TABLE course ALTER COLUMN subject_id SET NOT NULL;

-- Add NOT NULL to teacher_id
ALTER TABLE course ALTER COLUMN teacher_id SET NOT NULL;
```

## Data Model Improvements

### Current Flaws Identified:
1. **Separate student/teacher tables** - No unified user concept
2. **Missing constraints** - Allowed null foreign keys initially
3. **Feedback implementation** - Array type may not be optimal

### Suggested Improvements:

1. **Unified User Table Approach**:
```sql
CREATE TABLE user_account (
  user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email TEXT NOT NULL UNIQUE,
  date_of_birth DATE NOT NULL,
  is_teacher BOOLEAN DEFAULT FALSE,
  is_student BOOLEAN DEFAULT TRUE
);

-- Then reference this in other tables
ALTER TABLE course 
  RENAME COLUMN teacher_id TO instructor_id;

ALTER TABLE course 
  ALTER COLUMN instructor_id TYPE UUID USING (
    SELECT user_id FROM user_account 
    WHERE teacher_id = instructor_id
  );
```

2. **Better Feedback Implementation**:
```sql
-- Instead of array type in course table
CREATE TABLE course_feedback (
  feedback_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  course_id UUID NOT NULL REFERENCES course(course_id),
  student_id UUID NOT NULL REFERENCES student(student_id),
  rating SMALLINT CHECK (rating BETWEEN 1 AND 5),
  feedback_text TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);
```

## Key Lessons Learned

1. **Constraint Planning**:
   - Always define NOT NULL for required foreign keys upfront
   - Consider all business rules during schema design

2. **Data Migration**:
   - Must handle existing data before adding constraints
   - Temporary "fake" data can help transition
   - Maintenance windows may be needed for production changes

3. **Schema Evolution**:
   - Database designs evolve over time
   - ALTER TABLE is powerful but requires careful planning
   - Changes get harder as systems grow

4. **User Modeling**:
   - Separate student/teacher tables create duplication
   - Unified user model with roles is more flexible

5. **Validation**:
   - Add constraints early to catch design issues
   - Test with real-world scenarios before production

This process demonstrates the importance of thorough schema design while showing practical techniques for evolving a database structure as requirements change.