# SQL Table Creation and Constraints Explained

## Table Creation Basics

The text explains how to create tables in PostgreSQL with proper naming conventions and constraints. Here's a breakdown with examples:

### Basic CREATE TABLE Syntax
```sql
CREATE TABLE table_name (
  column1 datatype constraint,
  column2 datatype constraint,
  ...
);
```

### Example: Student Table
```sql
CREATE TABLE student (
  student_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL,
  date_of_birth DATE NOT NULL
);
```

**Key Points:**
- Table names are singular (`student`, not `students`)
- Column names follow consistent naming conventions
- Each column has a data type and optional constraints
- UUID is used as primary key with auto-generation

## Column Constraints

Constraints are rules applied to columns that enforce data integrity. Here are the main types with examples:

### 1. NOT NULL
Ensures a column cannot contain NULL values.

```sql
CREATE TABLE users (
  username VARCHAR(50) NOT NULL,
  password VARCHAR(50) NOT NULL
);
```

### 2. PRIMARY KEY
Uniquely identifies each record in a table. Automatically NOT NULL.

```sql
CREATE TABLE products (
  product_id SERIAL PRIMARY KEY,
  product_name VARCHAR(100)
);
```

### 3. UNIQUE
Ensures all values in a column are different.

```sql
CREATE TABLE employees (
  employee_id SERIAL PRIMARY KEY,
  email VARCHAR(100) UNIQUE,
  ssn VARCHAR(11) UNIQUE
);
```

### 4. CHECK
Validates that values meet specific conditions.

```sql
CREATE TABLE orders (
  order_id SERIAL PRIMARY KEY,
  amount DECIMAL(10,2) CHECK (amount > 0),
  order_date DATE CHECK (order_date <= CURRENT_DATE)
);
```

### 5. REFERENCES (Foreign Key)
Links to a column in another table.

```sql
CREATE TABLE orders (
  order_id SERIAL PRIMARY KEY,
  customer_id INTEGER REFERENCES customers(customer_id),
  order_date DATE
);
```

## Constraint Diagram

```
+---------------------+
|      Constraints    |
+----------+----------+
| Column-level        | Table-level
| (applied to single  | (can reference
|  column)            |  multiple columns)
+----------+----------+
| NOT NULL | PRIMARY  | PRIMARY KEY
| UNIQUE   | KEY      | (multi-column)
| CHECK    | (single  | UNIQUE
| DEFAULT  | column)  | (multi-column)
| FOREIGN  |          | FOREIGN KEY
| KEY      |          | CHECK
+---------------------+
```

## Practical Example with Multiple Constraints

```sql
CREATE TABLE employees (
  employee_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  first_name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  email VARCHAR(100) NOT NULL UNIQUE,
  hire_date DATE NOT NULL CHECK (hire_date <= CURRENT_DATE),
  salary DECIMAL(10,2) CHECK (salary > 0),
  department_id INTEGER REFERENCES departments(department_id),
  CONSTRAINT valid_email CHECK (email ~* '^[A-Za-z0-9._%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$')
);
```

**Key Takeaways:**
1. Constraints ensure data integrity at the database level
2. Column constraints apply to single columns
3. Table constraints (like multi-column PRIMARY KEY) apply to the whole table
4. Proper naming conventions make databases more maintainable
5. UUID is often better than sequential IDs for primary keys
6. The `uuid-ossp` extension must be enabled for UUID generation

Constraints are essential for maintaining data quality and relationships between tables in a relational database.