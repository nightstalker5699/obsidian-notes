# PostgreSQL Custom Data Types, Domains, and UUIDs Explained

## Custom Data Types in PostgreSQL

### Creating Composite Types
PostgreSQL allows you to create custom composite types that combine multiple fields:

```sql
-- Create a custom feedback type
CREATE TYPE feedback_type AS (
  student_id UUID,
  rating SMALLINT,
  feedback_text TEXT
);
```

### Using the Custom Type in a Table
```sql
CREATE TABLE courses (
  course_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  course_name VARCHAR(255) NOT NULL,
  feedback feedback_type[]  -- Array of feedback_type
);
```

## Domains: Constrained Type Aliases

Domains are custom data types with added constraints:

```sql
-- Create a domain for ratings (1-5)
CREATE DOMAIN rating AS SMALLINT
CHECK (VALUE > 0 AND VALUE <= 5);

-- Now use it in a table
CREATE TABLE course_feedback (
  feedback_id UUID PRIMARY KEY,
  student_id UUID NOT NULL,
  rating rating NOT NULL,  -- Uses our domain
  comment TEXT
);
```

## UUIDs Explained

### What is a UUID?
- Universally Unique Identifier (UUID)
- 128-bit number (32 hex digits, displayed as 8-4-4-4-12 format)
- Example: `123e4567-e89b-12d3-a456-426614174000`

### Enabling UUID Support
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

### Using UUIDs as Primary Keys
```sql
CREATE TABLE students (
  student_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE
);
```

### UUID Pros and Cons

| Pros | Cons |
|------|------|
| Globally unique across systems | Larger storage size (16 bytes vs 4 for INT) |
| No sequential numbering reveals system info | Slightly slower to index |
| No merge conflicts when combining data | Harder to read/debug |
| Better for distributed systems |  |
| More secure (can't guess next ID) |  |

## Practical Example Combining All Concepts

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create rating domain
CREATE DOMAIN valid_rating AS SMALLINT
CHECK (VALUE BETWEEN 1 AND 5);

-- Create custom feedback type
CREATE TYPE course_feedback AS (
  feedback_id UUID,
  student_id UUID,
  rating valid_rating,
  comment TEXT,
  submitted_at TIMESTAMP
);

-- Create courses table using all concepts
CREATE TABLE courses (
  course_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  course_name VARCHAR(255) NOT NULL,
  instructor_id UUID NOT NULL,
  feedback course_feedback[],
  CONSTRAINT fk_instructor FOREIGN KEY (instructor_id) REFERENCES teachers(teacher_id)
);
```

## When to Use Each Feature

1. **Custom Types**:
   - When you need to reuse a complex structure
   - For nested data that belongs together
   - When working with arrays of structured data

2. **Domains**:
   - When you need constrained versions of existing types
   - For business rules that apply to specific data fields
   - To standardize validation across multiple tables

3. **UUIDs**:
   - As primary keys in distributed systems
   - When you need to merge data from different sources
   - For security-sensitive applications
   - When you don't want to expose record counts

## Best Practices

1. **Naming Conventions**:
   - Types: `snake_case_type` (e.g., `feedback_type`)
   - Domains: `snake_case_domain` (e.g., `valid_rating`)
   - Always document your custom types and domains

2. **Validation**:
   - Put domain-specific validation in domains
   - Keep type definitions focused on structure
   - Use CHECK constraints for additional rules

3. **Performance**:
   - Consider using both UUID and sequential ID if needed
   - Index UUID columns properly
   - Be mindful of array sizes with custom types

These advanced PostgreSQL features provide powerful tools for modeling complex data while maintaining data integrity and consistency.