# SQL Table Constraints Explained with Examples

## Table Constraints vs Column Constraints

Table constraints differ from column constraints in that they:
- Apply to the entire table, not just single columns
- Can reference multiple columns
- Are defined after all columns are declared
- Must be explicitly named

### Key Differences

| Feature            | Column Constraints          | Table Constraints               |
|--------------------|----------------------------|---------------------------------|
| Scope              | Single column              | One or multiple columns         |
| Location           | With column definition     | After all column definitions    |
| Naming             | Automatic by PostgreSQL    | Must be explicitly named        |
| Best for           | Single-column rules        | Multi-column relationships/rules|

## Table Constraint Types with Examples

### 1. Primary Key (Multi-column)
```sql
CREATE TABLE order_items (
  order_id INTEGER,
  product_id INTEGER,
  quantity INTEGER,
  CONSTRAINT pk_order_items PRIMARY KEY (order_id, product_id)
);
```

### 2. Unique Constraint (Multi-column)
```sql
CREATE TABLE employee_departments (
  employee_id INTEGER,
  department_id INTEGER,
  start_date DATE,
  CONSTRAINT unique_employee_department UNIQUE (employee_id, department_id)
);
```

### 3. Check Constraint (Multi-column)
```sql
CREATE TABLE reservations (
  room_id INTEGER,
  start_date DATE,
  end_date DATE,
  CONSTRAINT valid_reservation_dates CHECK (end_date > start_date)
);
```

### 4. Foreign Key (Named)
```sql
CREATE TABLE enrollments (
  enrollment_id SERIAL PRIMARY KEY,
  student_id INTEGER,
  course_id INTEGER,
  CONSTRAINT fk_student FOREIGN KEY (student_id) REFERENCES students(student_id),
  CONSTRAINT fk_course FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

## Regular Expression Constraints

PostgreSQL supports regex pattern matching in CHECK constraints:

```sql
CREATE TABLE users (
  user_id SERIAL PRIMARY KEY,
  email TEXT CONSTRAINT valid_email 
    CHECK (email ~* '^[A-Za-z0-9._%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$'),
  phone TEXT CONSTRAINT valid_phone
    CHECK (phone ~ '^[0-9]{3}-[0-9]{3}-[0-9]{4}$')
);
```

**Regex Explanation:**
- `~*` = case insensitive regex match
- `^` = start of string
- `[A-Za-z0-9._%-]+` = one or more alphanumeric chars plus ._%-
- `@` = literal @ symbol
- `[.][A-Za-z]+$` = . followed by letters (domain suffix)

## Practical Example Combining Constraints

```sql
CREATE TABLE bank_transactions (
  transaction_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  from_account VARCHAR(20) NOT NULL,
  to_account VARCHAR(20) NOT NULL,
  amount DECIMAL(12,2) NOT NULL,
  transaction_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  status VARCHAR(10) NOT NULL,
  
  -- Table constraints
  CONSTRAINT valid_accounts CHECK (from_account != to_account),
  CONSTRAINT positive_amount CHECK (amount > 0),
  CONSTRAINT valid_status CHECK (status IN ('PENDING', 'COMPLETED', 'FAILED')),
  
  -- Named foreign key constraints
  CONSTRAINT fk_from_account FOREIGN KEY (from_account) REFERENCES accounts(account_number),
  CONSTRAINT fk_to_account FOREIGN KEY (to_account) REFERENCES accounts(account_number)
);
```

## Best Practices

1. **Naming Conventions**:
   - Primary keys: `pk_table_name`
   - Foreign keys: `fk_table_column`
   - Unique constraints: `uq_table_columns`
   - Check constraints: `ck_table_condition`

2. **Constraint Placement**:
   - Use column constraints for single-column rules
   - Use table constraints for multi-column rules
   - Always name your table constraints

3. **Validation Strategy**:
   - Simple validation (NOT NULL, length) at database level
   - Complex validation (business rules) at application level
   - Critical validation (data integrity) at both levels

4. **Performance Considerations**:
   - Constraints add overhead during INSERT/UPDATE
   - Use them judiciously for critical data integrity
   - Indexes are automatically created for PRIMARY KEY and UNIQUE constraints

Table constraints provide powerful tools to maintain data integrity across multiple columns while keeping your schema definition clean and organized.