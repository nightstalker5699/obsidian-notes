# Transactions in Database Management Systems

## What is a Transaction?

A transaction is a sequence of operations performed as a single logical unit of work in a database management system (DBMS). Transactions ensure data integrity when multiple users access a database concurrently.

### Key Characteristics:
- Transactions are atomic (all or nothing)
- They maintain database consistency
- They execute in isolation from other transactions
- Changes are durable once committed

## Transaction Lifecycle Diagram

```
          +---------------+
          |  Begin Transaction |
          +-------┬-------+
                  |
         +--------v--------+
         |   Active State   |
         +--------┬--------+
                  |
         +--------v--------+
         | Partially Committed |
         +--------┬--------+
                  |
       +----------v----------+
       | Commit or Rollback? |
       +----------+----------+
                  |
      +-----------v-----------+ 
      |                       |
+-----v-----+           +-----v-----+
| Committed |           |  Aborted  |
+-----------+           +-----------+
```

## ACID Properties of Transactions

| Property | Description | Example |
|----------|-------------|---------|
| **Atomicity** | All operations in a transaction complete successfully or none do | Transfer $100: debit one account AND credit another - both must succeed or both must fail |
| **Consistency** | Transactions bring the database from one valid state to another | Account balances must never be negative after a transaction |
| **Isolation** | Concurrent transactions don't interfere with each other | While one user updates a record, another user sees either the old or new value, not a partial update |
| **Durability** | Committed transactions persist even after system failures | After a bank confirms a transfer, the change remains even if the system crashes |

## Practical Examples

### Example 1: Simple Transaction

```sql
BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
  UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
COMMIT;
```

### Example 2: Transaction with Rollback

```sql
BEGIN TRANSACTION;
  INSERT INTO orders (customer_id, amount) VALUES (5, 99.99);
  -- If this fails, the entire transaction rolls back
  UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 42;
  
  -- If something goes wrong:
  -- ROLLBACK;
  
  -- If everything is OK:
COMMIT;
```

## Concurrency Control: Locking Example

```
Session 1:                          Session 2:
BEGIN;                              BEGIN;
DELETE FROM employees               DELETE FROM employees
WHERE id BETWEEN 10000 AND 10005;   WHERE id BETWEEN 10000 AND 10005;
(Executes immediately)              (Waits for lock)
COMMIT;                             (Now executes, but finds no rows to delete)
```

## Visualizing Isolation Levels

```
Time ->    T1            T2            T3
          BEGIN         BEGIN         BEGIN
          READ A=100    READ A=100    READ A=100
          A = A+50      A = A+20      A = A+30
          WRITE A=150   WRITE A=120   WRITE A=130
          COMMIT        COMMIT        COMMIT
          
Result depends on isolation level:
- Read Uncommitted: Could see intermediate values
- Read Committed: Sees only committed values
- Repeatable Read: Sees snapshot at transaction start
- Serializable: Transactions appear to execute sequentially
```

## Why Transactions Matter

Transactions are crucial for:
1. Maintaining data integrity in multi-user environments
2. Recovering from system failures
3. Implementing complex business logic reliably
4. Ensuring predictable behavior when operations span multiple tables or records

The ACID properties ensure that databases remain reliable even when many users are accessing and modifying data simultaneously.