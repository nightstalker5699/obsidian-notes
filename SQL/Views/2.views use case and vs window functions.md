# Practical Guide to Using SQL Views with Examples

This guide demonstrates how to use views to solve complex query problems, using the "current salary" example from the transcripts.

## Creating and Using Views: Current Salary Example

### Step 1: Create the View

First, we'll create a view that identifies the most recent salary change for each employee:

```sql
CREATE OR REPLACE VIEW last_salary_change AS
SELECT 
    employee_id,
    MAX(from_date) AS last_change_date
FROM salaries
GROUP BY employee_id;
```

### Step 2: Query the View

Now we can query this view like a regular table:

```sql
SELECT * FROM last_salary_change
ORDER BY employee_id;
```

### Step 3: Join the View with Other Tables

Use the view to get complete current salary information:

```sql
SELECT 
    s.employee_id,
    e.first_name,
    e.last_name,
    s.salary,
    s.from_date,
    s.to_date
FROM salaries s
JOIN last_salary_change lsc ON s.employee_id = lsc.employee_id 
                          AND s.from_date = lsc.last_change_date
JOIN employees e ON s.employee_id = e.employee_id
ORDER BY s.employee_id;
```

## Alternative Solution Using Window Functions

For comparison, here's the window function approach mentioned in the transcript:

```sql
SELECT DISTINCT ON (employee_id)
    employee_id,
    salary,
    from_date,
    to_date
FROM (
    SELECT 
        employee_id,
        salary,
        from_date,
        to_date,
        ROW_NUMBER() OVER (PARTITION BY employee_id ORDER BY from_date DESC) AS rn
    FROM salaries
) ranked_salaries
WHERE rn = 1
ORDER BY employee_id;
```

## Advantages of Using Views

1. **Readability**: The view-based solution is often easier to understand
2. **Reusability**: The view can be used in multiple queries
3. **Maintainability**: Changes only need to be made in one place (the view definition)
4. **Performance**: Can be materialized for better performance on complex queries

## Best Practices for Using Views

1. **Naming Conventions**: Use clear, descriptive names (e.g., `last_salary_change_v`)
2. **Documentation**: Add comments to explain the view's purpose
3. **Avoid Deep Nesting**: Don't create views that depend on many other views
4. **Consider Materialization**: For frequently accessed complex views
5. **Security**: Use views to restrict access to sensitive columns

## When to Use Views vs. Window Functions

| Use Case              | Views Approach                          | Window Functions Approach              |
|-----------------------|----------------------------------------|----------------------------------------|
| Simple to understand  | Better - simpler syntax                | More complex syntax                    |
| Performance           | Good with materialized views           | Can be slower on large datasets        |
| Reusability           | Excellent - can be used in many queries | Limited to single query                |
| Data freshness        | Always current (non-materialized)      | Always current                         |
| Complex calculations  | Can break into simpler steps           | Must be done in one complex statement  |

## Additional Practical Examples

### Example 1: Department Salary Summary View

```sql
CREATE VIEW department_salary_summary AS
SELECT 
    d.department_id,
    d.department_name,
    COUNT(e.employee_id) AS employee_count,
    AVG(s.salary) AS avg_salary,
    MAX(s.salary) AS max_salary,
    MIN(s.salary) AS min_salary
FROM departments d
JOIN employees e ON d.department_id = e.department_id
JOIN salaries s ON e.employee_id = s.employee_id
JOIN last_salary_change lsc ON s.employee_id = lsc.employee_id 
                          AND s.from_date = lsc.last_change_date
GROUP BY d.department_id, d.department_name;
```

### Example 2: Employee Current Details View

```sql
CREATE VIEW current_employee_details AS
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    e.email,
    d.department_name,
    t.title,
    s.salary,
    s.from_date AS salary_effective_date
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN titles t ON e.employee_id = t.employee_id
JOIN salaries s ON e.employee_id = s.employee_id
JOIN last_salary_change lsc ON s.employee_id = lsc.employee_id 
                          AND s.from_date = lsc.last_change_date
WHERE t.to_date = '9999-01-01';  -- Current title
```

Views provide a powerful way to simplify complex data access patterns and make your SQL code more maintainable and reusable.