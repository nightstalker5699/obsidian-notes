# Docker Compose Setup for Multi-Container Application

These transcripts show the process of creating a Docker Compose configuration for a development environment with multiple interconnected services.

## The Application Architecture

The application being set up has multiple components:

- Express server (backend API)
- React client (frontend)
- Worker process (background processing)
- PostgreSQL database (persistent data storage)
- Redis database (for caching and worker queue)
- Nginx (for routing)

## The Docker Compose Configuration Process

### Adding PostgreSQL

The first step involves creating a basic `docker-compose.yml` file and adding PostgreSQL:

```yaml
version: '3'
services:
  postgres:
    image: postgres:latest
```

This pulls the official PostgreSQL image from Docker Hub. Running `docker-compose up` at this stage would start a PostgreSQL container.

### Adding Redis

Redis is added as another service:

```yaml
redis:
  image: redis:latest
```

### Adding the Server Configuration

The server configuration requires more complex setup:

```yaml
server:
  build:
    dockerfile: Dockerfile.dev
    context: ./server
  volumes:
    - /app/node_modules
    - ./server:/app
```

This configuration:

- Specifies to use `Dockerfile.dev` for the development environment
- Sets the build context to the `/server` directory
- Creates a volume mapping that:
    - Preserves the container's `node_modules` folder
    - Maps the local server code to the `/app` directory in the container

### Adding Environment Variables

Environment variables are added to configure service connections:

```yaml
server:
  # previous configuration...
  environment:
    - REDIS_HOST=redis
    - REDIS_PORT=6379
    - PGUSER=postgres
    - PGHOST=postgres
    - PGDATABASE=postgres
    - PGPASSWORD=postgres
    - PGPORT=5432
```

These environment variables allow the Express server to:

1. Connect to Redis using the service name as the host
2. Connect to PostgreSQL using default credentials and the service name as the host

The final configuration provides a complete development environment where all services can communicate with each other, and code changes in the server directory are immediately reflected in the running container.

The remaining components (React client, worker, and Nginx) would be added to the Docker Compose file in a similar manner to complete the application infrastructure.