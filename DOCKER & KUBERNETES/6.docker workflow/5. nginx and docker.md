# Multi-Step Docker Builds for Production

## Core Concept: Multi-Stage Builds
- **Problem**: Need Node.js to build app but Nginx to serve it
- **Solution**: Use separate build and run phases
  - **Build phase**: Uses Node.js to install dependencies and create production build
  - **Run phase**: Uses lightweight Nginx to serve static files

## Why Nginx in Production?
- Development server (from `npm run start`) is inappropriate for production because:
  - Too resource-intensive
  - Not optimized for static file serving
  - Lacks production-grade security features
- Nginx is ideal for serving static files (HTML, JS, CSS)

## Production Dockerfile Structure

### Phase 1: Builder (Node.js)
```dockerfile
FROM node:alpine as builder
WORKDIR /app
COPY package.json .
RUN npm install
COPY . .
RUN npm run build
```
- Creates production assets in `/app/build` directory
- All intermediate files (node_modules, source code) will be discarded

### Phase 2: Runtime (Nginx)
```dockerfile
FROM nginx
COPY --from=builder /app/build /usr/share/nginx/html
```
- Copies **only** the built assets from builder phase
- Nginx automatically serves files from `/usr/share/nginx/html`

## Key Benefits
1. **Smaller final image size** (excludes Node.js and dependencies)
2. **Better security** (no development tools in production)
3. **Optimized runtime** (Nginx excels at static file serving)

## Implementation Notes
- Tag phases with `as <name>` to reference them later
- Use `COPY --from=<phase>` to copy files between phases
- Nginx starts automatically - no need for explicit `CMD`

## Build Command
```bash
docker build -t my-app-prod .
```
The resulting image will be much smaller than if we used Node.js for both building and serving.