# Docker Testing Workflow Notes

## Running Tests in Containers

### Basic Test Execution
- Build image with development Dockerfile:
  ```bash
  docker build -f Dockerfile.dev .
  ```
- Run tests by overriding default command:
  ```bash
  docker run -it <image_id> npm run test
  ```
  - `-it` flags attach interactive terminal to test process

### The Volume Problem
- Changes to test files (`app.test.js`) weren't reflected because:
  1. Container uses snapshot of files at build time
  2. No volume mapping means no live updates

### Solution Approaches

#### 1. Piggybacking on Running Container
1. Start development container:
   ```bash
   docker-compose up
   ```
2. Get container ID:
   ```bash
   docker ps
   ```
3. Execute tests in running container:
   ```bash
   docker exec -it <container_id> npm run test
   ```
- **Pros**: Gets volume mappings from main container
- **Cons**: Requires remembering container ID and command

#### 2. Dedicated Test Service in Docker Compose
```yaml
services:
  test:
    build:
      context: .
      dockerfile: Dockerfile.dev
    volumes:
      - /app/node_modules
      - .:/app
    command: ["npm", "run", "test"]
```
- **Pros**: Single command (`docker-compose up`) starts everything
- **Cons**: No interactive test control (can't use P/Q/T commands)

## Interactive Test Limitations
- **Core Issue**: Docker attach only connects to primary process (PID 1)
- Test suites like Jest spawn child processes that handle interactivity
- **Workarounds**:
  1. Use Docker exec method for full interactivity
  2. Accept non-interactive testing via Docker Compose
  3. Use test suites without interactive requirements

## Key Takeaways
1. Volume mapping is essential for test file updates:
   ```yaml
   volumes:
     - /app/node_modules  # Preserve container modules
     - .:/app            # Map local files
   ```
2. Two main approaches:
   - **Development-focused**: Use `docker exec` for interactive testing
   - **CI-focused**: Use Docker Compose service for automation
3. No perfect solution exists - choose based on your workflow needs

## Production Considerations
- These solutions are for development only
- For CI/CD (like Travis CI), the non-interactive Docker Compose approach works well
- Remember to delete local `node_modules` to prevent dependency duplication