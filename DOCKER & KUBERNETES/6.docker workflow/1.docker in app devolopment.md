# Docker Development Workflow Notes

## Core Workflow Overview
- **Development** → **Testing** → **Deployment** → **Repeat**
- Uses GitHub as central code coordination point
- Two branches:
  - `feature branch`: Where all active development happens
  - `master branch`: Represents clean, production-ready code

## Key Steps
1. Developer pulls latest code from feature branch
2. Makes changes locally
3. Pushes changes back to feature branch (never directly to master)
4. Creates pull request to merge changes from feature → master
5. Pull request triggers automated testing via Travis CI
6. If tests pass:
   - Code merges to master
   - Travis CI automatically deploys to AWS (Elastic Beanstalk)

## Docker's Role
- **Not required** for this workflow, but makes tasks easier
- Helps with:
  - Consistent development environments
  - Packaging applications for deployment
  - Running tests in isolated environments

## Project Setup
- Uses a simple React application (generated, no custom code needed)
- Key commands:
  - `npm run start`: Development server (not for production)
  - `npm run test`: Runs tests
  - `npm run build`: Creates production-optimized build

## Docker Configuration
- Two Dockerfiles:
  - `Dockerfile.dev`: For development environment
    - Base image: `node:alpine`
    - Copies package.json first for efficient layer caching
    - Runs `npm install`
    - Copies all files
    - Runs `npm run start`
  - `Dockerfile`: For production (to be created later)
- Build development image with:
  ```bash
  docker build -f Dockerfile.dev .
  ```

## Key Takeaways
- Workflow enables continuous development/deployment cycle
- Docker simplifies environment consistency but isn't mandatory
- Testing gate ensures only working code gets deployed
- Same pattern applies to other languages/frameworks with their equivalent commands